INF Creating interpreted sort Bool as (Bool).
INF Creating interpreted sort Int as (Int).
INF Creating uninterpreted sort IntP.
INF Creating uninterpreted sort BoolP.
INF Creating interpreted sort Var as (Var).
INF Creating uninterpreted sort AExp.
INF Creating uninterpreted sort BExp.
INF Creating uninterpreted sort NonValAExp.
INF Creating uninterpreted sort NonValBExp.
INF Creating uninterpreted sort Stmt.
INF Creating uninterpreted sort Code.
INF Creating uninterpreted sort CompStack.
INF Creating interpreted sort Map as ((Array Var Int)).
INF Creating uninterpreted sort CfgI.
INF Creating uninterpreted sort State.
INF Creating interpreted sort VarF as (VarF).
INF Creating uninterpreted sort ExpF.
INF Creating uninterpreted sort NonValExpF.
INF Creating uninterpreted sort ValExpF.
INF Creating uninterpreted sort CfgF.
INF Declaring the sorts: Int as subsorts of IntP 
INF Declaring the sorts: IntP as subsorts of AExp 
INF Declaring the sorts: Var as subsorts of NonValAExp 
INF Declaring the sorts: NonValAExp as subsorts of AExp 
INF Declaring the sorts: NonValBExp as subsorts of BExp 
INF Declaring the sorts: AExp BExp Stmt as subsorts of Code 
INF Declaring the sorts: Bool as subsorts of BoolP 
INF Declaring the sorts: BoolP as subsorts of BExp 
INF Declaring the sorts: AExp as subsorts of Stmt 
INF Declaring the sorts: BExp as subsorts of Stmt 
INF Declaring the sorts: Bool as subsorts of ValExpF 
INF Declaring the sorts: Int as subsorts of ValExpF 
INF Declaring the sorts: Var as subsorts of NonValExpF 
INF Declaring the sorts: VarF as subsorts of ExpF 
INF Declaring the sorts: ValExpF as subsorts of ExpF 
INF Declaring the sorts: NonValExpF as subsorts of ExpF 
INF Creating interpreted function 0 (as 0) :  -> Int
INF Creating interpreted function 1 (as 1) :  -> Int
INF Creating interpreted function 2 (as 2) :  -> Int
INF Creating interpreted function 3 (as 3) :  -> Int
INF Creating interpreted function 4 (as 4) :  -> Int
INF Creating interpreted function 5 (as 5) :  -> Int
INF Creating interpreted function 6 (as 6) :  -> Int
INF Creating interpreted function 7 (as 7) :  -> Int
INF Creating interpreted function 8 (as 8) :  -> Int
INF Creating interpreted function 9 (as 9) :  -> Int
INF Creating interpreted function 10 (as 10) :  -> Int
INF Creating interpreted function 11 (as 11) :  -> Int
INF Creating interpreted function 12 (as 12) :  -> Int
INF Creating interpreted function 13 (as 13) :  -> Int
INF Creating interpreted function 14 (as 14) :  -> Int
INF Creating interpreted function 15 (as 15) :  -> Int
INF Creating interpreted function mplus (as +) : Int Int  -> Int
INF Creating interpreted function mminus (as -) : Int Int  -> Int
INF Creating interpreted function mtimes (as *) : Int Int  -> Int
INF Creating interpreted function mdiv (as div) : Int Int  -> Int
INF Creating interpreted function mmod (as mod) : Int Int  -> Int
INF Creating interpreted function mle (as <=) : Int Int  -> Bool
INF Creating interpreted function mless (as <) : Int Int  -> Bool
INF Creating interpreted function mequals (as =) : Int Int  -> Bool
INF Creating interpreted function true (as true) :  -> Bool
INF Creating interpreted function false (as false) :  -> Bool
INF Creating interpreted function bnot (as not) : Bool  -> Bool
INF Creating interpreted function band (as and) : Bool Bool  -> Bool
INF Creating interpreted function biff (as iff) : Bool Bool  -> Bool
INF Creating interpreted function bor (as or) : Bool Bool  -> Bool
INF Creating interpreted function bimplies (as =>) : Bool Bool  -> Bool
INF Creating interpreted function bequals (as =) : Bool Bool  -> Bool
INF Creating uninterpreted function pair : CfgI CfgF  -> State
INF Creating interpreted function sum (as sum) : Int Int  -> Int
INF Creating interpreted function mapequals (as =) : Map Map  -> Bool
INF Creating interpreted function vfequals (as =) : VarF VarF  -> Bool
INF Creating uninterpreted function miu : VarF ExpF  -> NonValExpF
INF Creating uninterpreted function lam : VarF ExpF  -> ValExpF
INF Creating uninterpreted function fplus : ExpF ExpF  -> NonValExpF
INF Creating uninterpreted function fminus : ExpF ExpF  -> NonValExpF
INF Creating uninterpreted function fle : ExpF ExpF  -> NonValExpF
INF Creating uninterpreted function fless : ExpF ExpF  -> NonValExpF
INF Creating uninterpreted function fite : ExpF ExpF ExpF  -> NonValExpF
INF Creating uninterpreted function app : ExpF ExpF  -> NonValExpF
INF Creating uninterpreted function fassign : Var ExpF  -> NonValExpF
INF Creating uninterpreted function F : ExpF  -> CfgF
INF Creating uninterpreted function contextexp : ValExpF Map  -> ValExpF
INF Creating uninterpreted function contextexp : NonValExpF Map  -> NonValExpF
INF Creating interpreted function fvarX (as fvarX) :  -> VarF
INF Creating interpreted function fvarY (as fvarY) :  -> VarF
INF Creating interpreted function fvarZ (as fvarZ) :  -> VarF
INF Creating interpreted function fvarF (as fvarF) :  -> VarF
INF Creating uninterpreted function substitute : VarF ExpF ExpF  -> ExpF
INF Creating interpreted function x (as varX) :  -> Var
INF Creating interpreted function y (as varY) :  -> Var
INF Creating interpreted function z (as varZ) :  -> Var
INF Creating interpreted function pV1 (as varV1) :  -> Var
INF Creating interpreted function pV2 (as varV2) :  -> Var
INF Creating interpreted function pC1 (as varC1) :  -> Var
INF Creating interpreted function pC2 (as varC2) :  -> Var
INF Creating uninterpreted function pS1 :  -> Stmt
INF Creating uninterpreted function pE1 :  -> NonValAExp
INF Creating interpreted function iS1 (as iS1) : Int Int Int Int  -> Int
INF Creating interpreted function iE1 (as iE1) : Int Int  -> Int
INF Creating interpreted function synEq (as =) : Var Var  -> Bool
INF Creating interpreted function update (as store) : Map Var Int  -> Map
INF Creating interpreted function lookup (as select) : Map Var  -> IntP
INF Creating interpreted function flookup (as select) : Map Var  -> Int
INF Creating uninterpreted function plus : AExp AExp  -> NonValAExp
INF Creating uninterpreted function plushl : AExp  -> AExp
INF Creating uninterpreted function plushr : AExp  -> AExp
INF Creating interpreted function muifun (as uifun) : Int Int  -> Int
INF Creating uninterpreted function uifun : AExp AExp  -> NonValAExp
INF Creating uninterpreted function uifunhl : AExp  -> AExp
INF Creating uninterpreted function uifunhr : AExp  -> AExp
INF Creating uninterpreted function minus : AExp AExp  -> NonValAExp
INF Creating uninterpreted function minushl : AExp  -> AExp
INF Creating uninterpreted function minushr : AExp  -> AExp
INF Creating uninterpreted function pred : AExp  -> NonValAExp
INF Creating uninterpreted function predh :  -> Stmt
INF Creating uninterpreted function succ : AExp  -> NonValAExp
INF Creating uninterpreted function succh :  -> Stmt
INF Creating uninterpreted function le : AExp AExp  -> NonValBExp
INF Creating uninterpreted function lehl : AExp  -> BExp
INF Creating uninterpreted function lehr : AExp  -> BExp
INF Creating uninterpreted function less : AExp AExp  -> NonValBExp
INF Creating uninterpreted function lesshl : AExp  -> BExp
INF Creating uninterpreted function lesshr : AExp  -> BExp
INF Creating uninterpreted function not : BExp  -> NonValBExp
INF Creating uninterpreted function noth :  -> Stmt
INF Creating uninterpreted function done :  -> CompStack
INF Creating uninterpreted function push : Code CompStack  -> CompStack
INF Creating uninterpreted function IC : CompStack Map  -> CfgI
INF Creating uninterpreted function assign : Var AExp  -> Stmt
INF Creating uninterpreted function assignh : Var  -> Stmt
INF Creating uninterpreted function skip :  -> Stmt
INF Creating uninterpreted function seq : Stmt Stmt  -> Stmt
INF Creating uninterpreted function ite : BExp Stmt Stmt  -> Stmt
INF Creating uninterpreted function iteh : Stmt Stmt  -> Stmt
INF Creating uninterpreted function while : BExp Stmt  -> Stmt
INF Creating uninterpreted function for : Var AExp AExp Stmt  -> Stmt
INF Creating uninterpreted function forhl : Var AExp Stmt  -> Stmt
INF Creating uninterpreted function forhr : Var AExp Stmt  -> Stmt
INF Creating uninterpreted function _existsAExp : AExp Bool  -> Bool
INF Creating uninterpreted function _existsBExp : BExp Bool  -> Bool
INF Creating uninterpreted function _existsBool : Bool Bool  -> Bool
INF Creating uninterpreted function _existsBoolP : BoolP Bool  -> Bool
INF Creating uninterpreted function _existsCfgF : CfgF Bool  -> Bool
INF Creating uninterpreted function _existsCfgI : CfgI Bool  -> Bool
INF Creating uninterpreted function _existsCode : Code Bool  -> Bool
INF Creating uninterpreted function _existsCompStack : CompStack Bool  -> Bool
INF Creating uninterpreted function _existsExpF : ExpF Bool  -> Bool
INF Creating uninterpreted function _existsInt : Int Bool  -> Bool
INF Creating uninterpreted function _existsIntP : IntP Bool  -> Bool
INF Creating uninterpreted function _existsMap : Map Bool  -> Bool
INF Creating uninterpreted function _existsNonValAExp : NonValAExp Bool  -> Bool
INF Creating uninterpreted function _existsNonValBExp : NonValBExp Bool  -> Bool
INF Creating uninterpreted function _existsNonValExpF : NonValExpF Bool  -> Bool
INF Creating uninterpreted function _existsState : State Bool  -> Bool
INF Creating uninterpreted function _existsStmt : Stmt Bool  -> Bool
INF Creating uninterpreted function _existsValExpF : ValExpF Bool  -> Bool
INF Creating uninterpreted function _existsVar : Var Bool  -> Bool
INF Creating uninterpreted function _existsVarF : VarF Bool  -> Bool
INF Parsed rewrite rule: substitute(XF,FEXP,I) => I
INF Parsed rewrite rule: substitute(XF,FEXP,B) => B
INF Parsed rewrite rule: substitute(XF,FEXP,XF) => FEXP
INF Parsed rewrite rule: substitute(fvarX,FEXP,fvarY) => fvarY
INF Parsed rewrite rule: substitute(fvarX,FEXP,fvarZ) => fvarZ
INF Parsed rewrite rule: substitute(fvarX,FEXP,fvarF) => fvarF
INF Parsed rewrite rule: substitute(fvarY,FEXP,fvarX) => fvarX
INF Parsed rewrite rule: substitute(fvarY,FEXP,fvarZ) => fvarZ
INF Parsed rewrite rule: substitute(fvarY,FEXP,fvarF) => fvarF
INF Parsed rewrite rule: substitute(fvarZ,FEXP,fvarY) => fvarY
INF Parsed rewrite rule: substitute(fvarZ,FEXP,fvarZ) => fvarZ
INF Parsed rewrite rule: substitute(fvarZ,FEXP,fvarF) => fvarF
INF Parsed rewrite rule: substitute(fvarF,FEXP,fvarX) => fvarX
INF Parsed rewrite rule: substitute(fvarF,FEXP,fvarY) => fvarY
INF Parsed rewrite rule: substitute(fvarF,FEXP,fvarZ) => fvarZ
INF Parsed rewrite rule: substitute(XF,FEXP,fplus(FEXP1,FEXP2)) => fplus(substitute(XF,FEXP,FEXP1),substitute(XF,FEXP,FEXP2))
INF Parsed rewrite rule: substitute(XF,FEXP,fminus(FEXP1,FEXP2)) => fminus(substitute(XF,FEXP,FEXP1),substitute(XF,FEXP,FEXP2))
INF Parsed rewrite rule: substitute(XF,FEXP,fless(FEXP1,FEXP2)) => fless(substitute(XF,FEXP,FEXP1),substitute(XF,FEXP,FEXP2))
INF Parsed rewrite rule: substitute(XF,FEXP,fle(FEXP1,FEXP2)) => fle(substitute(XF,FEXP,FEXP1),substitute(XF,FEXP,FEXP2))
INF Parsed rewrite rule: substitute(XF,FEXP,fite(FEXP1,FEXP2,FEXP3)) => fite(substitute(XF,FEXP,FEXP1),substitute(XF,FEXP,FEXP2),substitute(XF,FEXP,FEXP3))
INF Parsed rewrite rule: substitute(XF,FEXP,app(FEXP1,FEXP2)) => app(substitute(XF,FEXP,FEXP1),substitute(XF,FEXP,FEXP2))
INF Parsed rewrite rule: substitute(fvarX,FEXP1,lam(fvarY,FEXP)) => lam(fvarY,substitute(fvarX,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarX,FEXP1,lam(fvarZ,FEXP)) => lam(fvarZ,substitute(fvarX,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarX,FEXP1,lam(fvarF,FEXP)) => lam(fvarF,substitute(fvarX,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarY,FEXP1,lam(fvarX,FEXP)) => lam(fvarX,substitute(fvarY,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarY,FEXP1,lam(fvarZ,FEXP)) => lam(fvarZ,substitute(fvarY,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarY,FEXP1,lam(fvarF,FEXP)) => lam(fvarF,substitute(fvarY,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarZ,FEXP1,lam(fvarX,FEXP)) => lam(fvarX,substitute(fvarZ,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarZ,FEXP1,lam(fvarY,FEXP)) => lam(fvarY,substitute(fvarZ,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarZ,FEXP1,lam(fvarF,FEXP)) => lam(fvarF,substitute(fvarZ,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarF,FEXP1,lam(fvarX,FEXP)) => lam(fvarX,substitute(fvarF,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarF,FEXP1,lam(fvarY,FEXP)) => lam(fvarY,substitute(fvarF,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarF,FEXP1,lam(fvarZ,FEXP)) => lam(fvarZ,substitute(fvarF,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(XF,FEXP1,lam(XF,FEXP)) => lam(XF,FEXP)
INF Parsed rewrite rule: substitute(fvarX,FEXP1,miu(fvarY,FEXP)) => miu(fvarY,substitute(fvarX,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarX,FEXP1,miu(fvarZ,FEXP)) => miu(fvarZ,substitute(fvarX,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarX,FEXP1,miu(fvarF,FEXP)) => miu(fvarF,substitute(fvarX,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarY,FEXP1,miu(fvarX,FEXP)) => miu(fvarX,substitute(fvarY,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarY,FEXP1,miu(fvarZ,FEXP)) => miu(fvarZ,substitute(fvarY,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarY,FEXP1,miu(fvarF,FEXP)) => miu(fvarF,substitute(fvarY,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarZ,FEXP1,miu(fvarX,FEXP)) => miu(fvarX,substitute(fvarZ,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarZ,FEXP1,miu(fvarY,FEXP)) => miu(fvarY,substitute(fvarZ,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarZ,FEXP1,miu(fvarF,FEXP)) => miu(fvarF,substitute(fvarZ,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarF,FEXP1,miu(fvarX,FEXP)) => miu(fvarX,substitute(fvarF,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarF,FEXP1,miu(fvarY,FEXP)) => miu(fvarY,substitute(fvarF,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(fvarF,FEXP1,miu(fvarZ,FEXP)) => miu(fvarZ,substitute(fvarF,FEXP1,FEXP))
INF Parsed rewrite rule: substitute(XF,FEXP1,miu(XF,FEXP)) => miu(XF,FEXP)
INF Parsed rewrite rule: IC(push(X,REST),ENV) if true => IC(push(lookup(ENV,X),REST),ENV)
INF Parsed rewrite rule: IC(push(pred(N),REST),ENV) if true => IC(push(mminus(N,1),REST),ENV)
INF Parsed rewrite rule: IC(push(pred(NVAE),REST),ENV) if true => IC(push(NVAE,push(predh,REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(predh,REST)),ENV) if true => IC(push(pred(N),REST),ENV)
INF Parsed rewrite rule: IC(push(not(B),REST),ENV) if true => IC(push(bnot(B),REST),ENV)
INF Parsed rewrite rule: IC(push(not(NVBE),REST),ENV) if true => IC(push(NVBE,push(noth,REST)),ENV)
INF Parsed rewrite rule: IC(push(B,push(noth,REST)),ENV) if true => IC(push(not(B),REST),ENV)
INF Parsed rewrite rule: IC(push(succ(N),REST),ENV) if true => IC(push(mplus(N,1),REST),ENV)
INF Parsed rewrite rule: IC(push(succ(NVAE),REST),ENV) if true => IC(push(NVAE,push(succh,REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(succh,REST)),ENV) if true => IC(push(succ(N),REST),ENV)
INF Parsed rewrite rule: IC(push(assign(X,N),REST),ENV) if true => IC(REST,update(ENV,X,N))
INF Parsed rewrite rule: IC(push(assign(X,NVAE),REST),ENV) if true => IC(push(NVAE,push(assignh(X),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(assignh(X),REST)),ENV) if true => IC(push(assign(X,N),REST),ENV)
INF Parsed rewrite rule: IC(push(seq(S1,S2),REST),ENV) if true => IC(push(S1,push(S2,REST)),ENV)
INF Parsed rewrite rule: IC(push(skip,REST),ENV) if true => IC(REST,ENV)
INF Parsed rewrite rule: IC(push(ite(NVBE,S1,S2),REST),ENV) if true => IC(push(NVBE,push(iteh(S1,S2),REST)),ENV)
INF Parsed rewrite rule: IC(push(B,push(iteh(S1,S2),REST)),ENV) if true => IC(push(ite(B,S1,S2),REST),ENV)
INF Parsed rewrite rule: IC(push(ite(true,S1,S2),REST),ENV) if true => IC(push(S1,REST),ENV)
INF Parsed rewrite rule: IC(push(ite(false,S1,S2),REST),ENV) if true => IC(push(S2,REST),ENV)
INF Parsed rewrite rule: IC(push(while(BE,S),REST),ENV) if true => IC(push(ite(BE,seq(S,while(BE,S)),skip),REST),ENV)
INF Parsed rewrite rule: IC(push(plus(N,M),REST),ENV) if true => IC(push(mplus(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(plus(NVAE1,AE2),REST),ENV) if true => IC(push(NVAE1,push(plushl(AE2),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(plushl(AE2),REST)),ENV) if true => IC(push(plus(N,AE2),REST),ENV)
INF Parsed rewrite rule: IC(push(plus(N,NVAE2),REST),ENV) if true => IC(push(NVAE2,push(plushr(N),REST)),ENV)
INF Parsed rewrite rule: IC(push(M,push(plushr(N),REST)),ENV) if true => IC(push(plus(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(uifun(N,M),REST),ENV) if true => IC(push(muifun(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(uifun(NVAE1,AE2),REST),ENV) if true => IC(push(NVAE1,push(uifunhl(AE2),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(uifunhl(AE2),REST)),ENV) if true => IC(push(uifun(N,AE2),REST),ENV)
INF Parsed rewrite rule: IC(push(uifun(N,NVAE2),REST),ENV) if true => IC(push(NVAE2,push(uifunhr(N),REST)),ENV)
INF Parsed rewrite rule: IC(push(M,push(uifunhr(N),REST)),ENV) if true => IC(push(uifun(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(minus(N,M),REST),ENV) if true => IC(push(mminus(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(minus(NVAE1,AE2),REST),ENV) if true => IC(push(NVAE1,push(minushl(AE2),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(minushl(AE2),REST)),ENV) if true => IC(push(minus(N,AE2),REST),ENV)
INF Parsed rewrite rule: IC(push(minus(N,NVAE2),REST),ENV) if true => IC(push(NVAE2,push(minushr(N),REST)),ENV)
INF Parsed rewrite rule: IC(push(M,push(minushr(N),REST)),ENV) if true => IC(push(minus(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(for(X,NVAE1,NVAE2,S),REST),ENV) if true => IC(push(NVAE1,push(forhl(X,NVAE2,S),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(forhl(X,NVAE2,S),REST)),ENV) if true => IC(push(for(X,N,NVAE2,S),REST),ENV)
INF Parsed rewrite rule: IC(push(for(X,N,NVAE2,S),REST),ENV) if true => IC(push(NVAE2,push(forhr(X,N,S),REST)),ENV)
INF Parsed rewrite rule: IC(push(M,push(forhr(X,N,S),REST)),ENV) if true => IC(push(for(X,N,M,S),REST),ENV)
INF Parsed rewrite rule: IC(push(for(X,N,M,S),REST),ENV) if mle(N,M) => IC(push(seq(assign(X,N),S),push(for(X,mplus(N,1),M,S),REST)),ENV)
INF Parsed rewrite rule: IC(push(for(X,N,M,S),REST),ENV) if bnot(mle(N,M)) => IC(REST,ENV)
INF Parsed rewrite rule: IC(push(le(N,M),REST),ENV) if true => IC(push(mle(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(le(NVAE1,AE2),REST),ENV) if true => IC(push(NVAE1,push(lehl(AE2),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(lehl(AE2),REST)),ENV) if true => IC(push(le(N,AE2),REST),ENV)
INF Parsed rewrite rule: IC(push(le(N,NVAE2),REST),ENV) if true => IC(push(NVAE2,push(lehr(N),REST)),ENV)
INF Parsed rewrite rule: IC(push(M,push(lehr(N),REST)),ENV) if true => IC(push(le(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(less(N,M),REST),ENV) if true => IC(push(mless(N,M),REST),ENV)
INF Parsed rewrite rule: IC(push(less(NVAE1,AE2),REST),ENV) if true => IC(push(NVAE1,push(lesshl(AE2),REST)),ENV)
INF Parsed rewrite rule: IC(push(N,push(lesshl(AE2),REST)),ENV) if true => IC(push(less(N,AE2),REST),ENV)
INF Parsed rewrite rule: IC(push(less(N,NVAE2),REST),ENV) if true => IC(push(NVAE2,push(lesshr(N),REST)),ENV)
INF Parsed rewrite rule: IC(push(M,push(lesshr(N),REST)),ENV) if true => IC(push(less(N,M),REST),ENV)
INF Parsed rewrite rule: contextexp(fplus(FNV,FEXP),ENV) if true => fplus(contextexp(FNV,ENV),FEXP)
INF Parsed rewrite rule: fplus(contextexp(I,ENV),FEXP) if true => contextexp(fplus(I,FEXP),ENV)
INF Parsed rewrite rule: contextexp(fplus(I,FNV),ENV) if true => fplus(I,contextexp(FNV,ENV))
INF Parsed rewrite rule: fplus(I,contextexp(J,ENV)) if true => contextexp(fplus(I,J),ENV)
INF Parsed rewrite rule: contextexp(fplus(I,J),ENV) if true => contextexp(mplus(I,J),ENV)
INF Parsed rewrite rule: contextexp(fminus(FNV,FEXP),ENV) if true => fminus(contextexp(FNV,ENV),FEXP)
INF Parsed rewrite rule: fminus(contextexp(I,ENV),FEXP) if true => contextexp(fminus(I,FEXP),ENV)
INF Parsed rewrite rule: contextexp(fminus(I,FNV),ENV) if true => fminus(I,contextexp(FNV,ENV))
INF Parsed rewrite rule: fminus(I,contextexp(J,ENV)) if true => contextexp(fminus(I,J),ENV)
INF Parsed rewrite rule: contextexp(fminus(I,J),ENV) if true => contextexp(mminus(I,J),ENV)
INF Parsed rewrite rule: contextexp(fless(FNV,FEXP),ENV) if true => fless(contextexp(FNV,ENV),FEXP)
INF Parsed rewrite rule: fless(contextexp(I,ENV),FEXP) if true => contextexp(fless(I,FEXP),ENV)
INF Parsed rewrite rule: contextexp(fless(I,FNV),ENV) if true => fless(I,contextexp(FNV,ENV))
INF Parsed rewrite rule: fless(I,contextexp(J,ENV)) if true => contextexp(fless(I,J),ENV)
INF Parsed rewrite rule: contextexp(fless(I,J),ENV) if true => contextexp(mless(I,J),ENV)
INF Parsed rewrite rule: contextexp(fle(FNV,FEXP),ENV) if true => fle(contextexp(FNV,ENV),FEXP)
INF Parsed rewrite rule: fle(contextexp(I,ENV),FEXP) if true => contextexp(fle(I,FEXP),ENV)
INF Parsed rewrite rule: contextexp(fle(I,FNV),ENV) if true => fle(I,contextexp(FNV,ENV))
INF Parsed rewrite rule: fle(I,contextexp(J,ENV)) if true => contextexp(fle(I,J),ENV)
INF Parsed rewrite rule: contextexp(fle(I,J),ENV) if true => contextexp(mle(I,J),ENV)
INF Parsed rewrite rule: contextexp(fite(FNV,FEXP1,FEXP2),ENV) if true => fite(contextexp(FNV,ENV),FEXP1,FEXP2)
INF Parsed rewrite rule: fite(contextexp(B,ENV),FEXP1,FEXP2) if true => contextexp(fite(B,FEXP1,FEXP2),ENV)
INF Parsed rewrite rule: contextexp(fite(true,FEXP1,FEXP2),ENV) if true => contextexp(FEXP1,ENV)
INF Parsed rewrite rule: contextexp(fite(false,FEXP1,FEXP2),ENV) if true => contextexp(FEXP2,ENV)
INF Parsed rewrite rule: contextexp(app(FNV,FEXP),ENV) if true => app(contextexp(FNV,ENV),FEXP)
INF Parsed rewrite rule: app(contextexp(lam(XF,FEXP1),ENV),FEXP2) if true => contextexp(app(lam(XF,FEXP1),FEXP2),ENV)
INF Parsed rewrite rule: contextexp(app(lam(XF,FEXP1),FNV),ENV) if true => app(lam(XF,FEXP1),contextexp(FNV,ENV))
INF Parsed rewrite rule: app(lam(XF,FEXP1),contextexp(VF,ENV)) if true => contextexp(app(lam(XF,FEXP1),VF),ENV)
INF Parsed rewrite rule: contextexp(app(lam(XF,FEXP1),VF),ENV) if true => contextexp(substitute(XF,VF,FEXP1),ENV)
INF Parsed rewrite rule: contextexp(miu(XF,FEXP),ENV) if true => contextexp(substitute(XF,miu(XF,FEXP),FEXP),ENV)
INF Parsed rewrite rule: contextexp(fassign(X,I),ENV) if true => contextexp(I,update(ENV,X,I))
INF Parsed rewrite rule: contextexp(fassign(X,FNV),ENV) if true => fassign(X,contextexp(FNV,ENV))
INF Parsed rewrite rule: fassign(X,contextexp(I,ENV)) if true => contextexp(fassign(X,I),ENV)
INF Parsed rewrite rule: contextexp(X,ENV) if true => contextexp(flookup(ENV,X),ENV)
INF Parsed rewrite rule: F(contextexp(fplus(fassign(X,2),X),ENV1)) if true => F(contextexp(4,ENV2))
INF false

Proving circularity #1:
--------
INF Trying to prove F(contextexp(fplus(fassign(X,2),X),ENV1)) if true => F(contextexp(4,ENV2))
PROVING F(contextexp(fplus(fassign(X,2),X),ENV1)) if true => F(contextexp(4,ENV2))
INF     RHS is not an instance of LHS in any case (no mgu).
  IMPL if false
INF     Circularities apply in case: false
  CIRC if false
INF     Trying to prove F(fplus(contextexp(fassign(X,2),ENV1),X)) if true => F(contextexp(4,ENV2))
    PROVING F(fplus(contextexp(fassign(X,2),ENV1),X)) if true => F(contextexp(4,ENV2))
INF         RHS is not an instance of LHS in any case (no mgu).
      IMPL if false
INF         Circularities apply in case: false
      CIRC if false
INF         Trying to prove F(fplus(contextexp(2,update(ENV1,X,2)),X)) if true => F(contextexp(4,ENV2))
        PROVING F(fplus(contextexp(2,update(ENV1,X,2)),X)) if true => F(contextexp(4,ENV2))
INF             RHS is not an instance of LHS in any case (no mgu).
          IMPL if false
INF             Circularities apply in case: false
          CIRC if false
INF             Trying to prove F(contextexp(fplus(2,X),update(ENV1,X,2))) if true => F(contextexp(4,ENV2))
            PROVING F(contextexp(fplus(2,X),update(ENV1,X,2))) if true => F(contextexp(4,ENV2))
INF                 RHS is not an instance of LHS in any case (no mgu).
              IMPL if false
INF                 Circularities apply in case: false
              CIRC if false
INF                 Trying to prove F(fplus(2,contextexp(X,update(ENV1,X,2)))) if true => F(contextexp(4,ENV2))
                PROVING F(fplus(2,contextexp(X,update(ENV1,X,2)))) if true => F(contextexp(4,ENV2))
INF                     RHS is not an instance of LHS in any case (no mgu).
                  IMPL if false
INF                     Circularities apply in case: false
                  CIRC if false
INF                     Trying to prove F(fplus(2,contextexp(flookup(update(ENV1,X,2),X),update(ENV1,X,2)))) if true => F(contextexp(4,ENV2))
                    PROVING F(fplus(2,contextexp(flookup(update(ENV1,X,2),X),update(ENV1,X,2)))) if true => F(contextexp(4,ENV2))
INF                         RHS is not an instance of LHS in any case (no mgu).
                      IMPL if false
INF                         Circularities apply in case: false
                      CIRC if false
INF                         Trying to prove F(contextexp(fplus(2,flookup(update(ENV1,X,2),X)),update(ENV1,X,2))) if true => F(contextexp(4,ENV2))
                        PROVING F(contextexp(fplus(2,flookup(update(ENV1,X,2),X)),update(ENV1,X,2))) if true => F(contextexp(4,ENV2))
INF                             RHS is not an instance of LHS in any case (no mgu).
                          IMPL if false
INF                             Circularities apply in case: false
                          CIRC if false
INF                             Trying to prove F(contextexp(mplus(2,flookup(update(ENV1,X,2),X)),update(ENV1,X,2))) if true => F(contextexp(4,ENV2))
                            PROVING F(contextexp(mplus(2,flookup(update(ENV1,X,2),X)),update(ENV1,X,2))) if true => F(contextexp(4,ENV2))
INF                                 RHS is an instance of LHS in case band(mapequals(_84,_82),band(mequals(_83,_81),band(mapequals(_84,ENV2),band(mequals(_83,4),band(mapequals(_82,update(ENV1,X,2)),mequals(_81,mplus(2,flookup(update(ENV1,X,2),X))))))))
                              IMPL if (and (= _84 _82) (and (= _83 _81) (and (= _84 ENV2) (and (= _83 4) (and (= _82 (store ENV1 X 2)) (= _81 (+ 2 (select (store ENV1 X 2) X))))))))
INF                                 Circularities apply in case: false
                              CIRC if false
INF                                 Rewrite rules apply in case: false
                              REWR if false
                            ! Remaining proof obligation:F(contextexp((+ 2 (select (store ENV1 X 2) X)),(store ENV1 X 2))) if (not (and (= _84 _82) (and (= _83 _81) (and (= _84 ENV2) (and (= _83 4) (and (= _82 (store ENV1 X 2)) (= _81 (+ 2 (select (store ENV1 X 2) X))))))))) => F(contextexp(4,ENV2))
                            * Assuming that F(contextexp((+ 2 (select (store ENV1 X 2) X)),(store ENV1 X 2))) if true => F(contextexp(4,ENV2))
INF                             Rewrite rules apply in case: true
                          REWR if true
                        OKAY
INF                         Rewrite rules apply in case: true
                      REWR if true
                    OKAY
INF                     Rewrite rules apply in case: true
                  REWR if true
                OKAY
INF                 Rewrite rules apply in case: true
              REWR if true
            OKAY
INF             Rewrite rules apply in case: true
          REWR if true
        OKAY
INF         Rewrite rules apply in case: true
      REWR if true
    OKAY
INF     Rewrite rules apply in case: true
  REWR if true
OKAY
--------
Circularity #1 not proved. The following proof obligations failed:
Remaining proof obligation #1 (reason: could not prove completeness): F(contextexp((+ 2 (select (store ENV1 X 2) X)),(store ENV1 X 2))) if (not (and (= _84 _82) (and (= _83 _81) (and (= _84 ENV2) (and (= _83 4) (and (= _82 (store ENV1 X 2)) (= _81 (+ 2 (select (store ENV1 X 2) X))))))))) => F(contextexp(4,ENV2))
