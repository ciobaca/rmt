smt-prelude "(define-fun-rec gcd ((x Int) (y Int)) Int
     (ite (= y 0)
      x
      (gcd y (mod x y))
     )
)"

sorts Int / "Int", Bool / "Bool", State;
// subsort Int < State;

signature mzero : -> Int / "0", mone : -> Int / "1", mtwo : -> Int / "2", mthree : -> Int / "3",
  mplus : Int Int->Int / "+", mminus : Int Int->Int / "-",
  mtimes : Int Int->Int / "*", mdiv : Int Int->Int / "div",
  mle : Int Int->Bool / "<=", mequals : Int Int->Bool / "=",
  mgcd : Int Int -> Int / "gcd", mg : Int Int -> Bool / ">",
  mmod : Int Int -> Int / "mod",

  bequals : Bool Bool->Bool / "=", band : Bool Bool->Bool / "and",
  bimplies : Bool Bool->Bool / "=>", bor : Bool Bool->Bool / "or",
  bnot : Bool->Bool / "not", true : ->Bool / "true", false : ->Bool / "false",

  init : Int Int -> State, loop : Int Int Int Int Int Int Int Int -> State, done : Int Int Int Int Int -> State,
  ok : Int Int -> State;

variables S : Int, N : Int, I : Int, J : Int, X : Int, Y : Int, Z : Int, A : Int, B : Int,
 C : Int, D : Int;

rewrite-system simplifications
  bnot(false) => true, bnot(true) => false, bnot(bnot(B)) => B,
  band(false, B) => false, band(true, B) => B, band(B, false) => false,
  band(B, true) => B, bimplies(true, B) => B, bimplies(false, B) => true,
  bor(false, B) => B, bor(true, B) => true, bor(B, false) => B,
  bor(B, true) => true, mequals(N, N) => true, bequals(B, B) => true,
  bequals(true, B) => B,bequals(false, B) => bnot(B), bequals(B, true) => B,
  bequals(B, false) => bnot(B), band(B, B) => B, bor(B, B) => B;

constrained-rewrite-system gcd
  init(X, Y) => loop(X, Y, X, Y, mone, mzero, mzero, mone),

  loop(I, J, X, Y, A, B, C, D) /\ bnot(mequals(Y, mzero)) =>
  loop(I, J, Y, mminus(X, mtimes(mdiv(X, Y), Y)),
       C, D,
       mminus(A, mtimes(mdiv(X, Y), C)), mminus(B, mtimes(mdiv(X, Y), D))),

  loop(I, J, X, Y, A, B, C, D) /\ mequals(Y, mzero) => done(I, J, X, A, B),

  done(I, J, mgcd(I, J), A, B) /\ mequals(mgcd(I, J), mplus(mtimes(A, I), mtimes(B, J))) => ok(I, J);

constrained-rewrite-system circ
  init(X, Y) => ok(X, Y),

  loop(I, J, X, Y, A, B, C, D) /\ band(
  	  mequals(X, mplus(mtimes(A, I), mtimes(B, J))),
	  mequals(Y, mplus(mtimes(C, I), mtimes(D, J)))) => ok(I, J);

prove in gcd : circ;
