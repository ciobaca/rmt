/*

  Simple example which simulates the addition of two numbers in linear
  time. Consider the following rewrite rules:

  loop(x, y) /\ ~ (y <= 0) => loop(x + 1, y - 1),
  loop(x, y) /\ y <= 0 => done(x);

  We try to prove the total correctness specification:

  loop(x, y) /\ ~ (y <= 0) => done(x + y),

  but we use the wrong variant.

  This example shows that if we use a bad variant (trying to show the
  final state is reached in at most y steps -- instead of y + 2), then
  the proof fails.

*/
sorts Int/"Int", Bool/"Bool", State, nState;

signature mzero:->Int/"0", mone:->Int/"1", mtwo:->Int/"2",
  mplus:Int Int->Int/"+", mminus:Int Int->Int/"-",
  mtimes:Int Int->Int/"*", mdiv:Int Int->Int/"div",
  mle:Int Int->Bool/"<=", mequals:Int Int->Bool/"=",

  bequals:Bool Bool->Bool/"=", band:Bool Bool->Bool/"and",
  bimplies:Bool Bool->Bool/"=>", bor:Bool Bool->Bool/"or",
  bnot:Bool->Bool/"not", true:->Bool/"true", false:->Bool/"false",

  init:Int Int->State, loop:Int Int->State, done:Int->State,
  protect:State Int->nState;

variables B:Bool, S:Int, N:Int, I:Int, x:Int, y:Int, VN:Int, VI:Int, REZ:Int;

/* rewrite system used by the system to simplify constraints */
rewrite-system simplifications
  bnot(false)=>true, bnot(true)=>false, bnot(bnot(B))=>B,
  band(false, B)=>false, band(true, B)=>B, band(B, false)=>false,
  band(B, true)=>B, bimplies(true, B)=>B, bimplies(false, B)=>true,
  bor(false, B)=>B, bor(true, B)=>true, bor(B, false)=>B,
  bor(B, true)=>true, mequals(N, N)=>true, bequals(B, B)=>true,
  bequals(true, B)=>B,bequals(false, B)=>bnot(B), bequals(B, true)=>B,
  bequals(B, false)=>bnot(B), band(B, B)=>B, bor(B, B)=>B;

/*** Rewrite Rules ***/
constrained-rewrite-system sum
  loop(x, y) /\ bnot(mle(y,mzero)) => loop(mplus(x,mone), mminus(y,mone)),
  loop(x, y) /\ mle(y,mzero) => done(x);

/*** Proof Obligation ***/
constrained-rewrite-system circularities
  loop(x, y) /\ bnot(mle(y,mzero)) => done(mplus(x,y));

// the following command would prove the obligations (in the sense of
// partial correctness)
// prove in sum : circularities;

// the following commands transform
// 1. the initial rewrite system "sum", generating "sum_protected" and
instrument sum sum_protected State nState protect;

// 2. the proof obligations "circularities", generating "circularities_protected"
// note the use of the wrong upper bound "y" instead of the correct "y + 2"
// "State" and "nState" denote the sorts of the old configuration and resp. new configuration
cinstrument circularities circularities_protected State nState protect y;

// the following proves the partial correctness of the proof obligations
// "circularities_protected" in the rewrite system "sum_protected"
prove in sum_protected : circularities_protected;

// the proof fails, as expected (the output is "... Circularity #1 not proved. ...")
