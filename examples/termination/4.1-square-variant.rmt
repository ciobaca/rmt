/*

  This is an example that computes the sum of the first N naturals, in
  N^2 steps.

  Here is the rewrite system:

  a(n) => b(n, s(mzero)),
  b(n, x) => c(n, n, x),
  c(m, s(N), s(X)) /\ band(mle(mone,N),mle(mzero,X)) => c(m, s(mminus(N,mone)), s(mplus(X,mone))),
  c(s(M), s(mzero), x) /\ mle(mone,M) => c(s(mminus(M,mone)), s(mminus(M,mone)), x),
  c(s(mzero), s(mzero), x) => d(x);

Run with:
> rmt[.exe] -v 0 < 4.1-square-variant.rmt | grep "#"
Expected output:
Proving circularity #1:
Circularity #1 proved.
Proving circularity #2:
Circularity #2 proved.
*/
sorts Int/"Int", Bool/"Bool", State, nState, Nat;

signature mzero:->Int/"0", mone:->Int/"1", mtwo:->Int/"2", mthree:->Int/"3", mhundred:->Int/"100",
  mplus:Int Int->Int/"+", mminus:Int Int->Int/"-",
  mtimes:Int Int->Int/"*", mdiv:Int Int->Int/"div",
  mle:Int Int->Bool/"<=", mequals:Int Int->Bool/"=",

  bequals:Bool Bool->Bool/"=", band:Bool Bool->Bool/"and",
  bimplies:Bool Bool->Bool/"=>", bor:Bool Bool->Bool/"or",
  bnot:Bool->Bool/"not", true:->Bool/"true", false:->Bool/"false",

  a:Nat->State, b:Nat Nat->State, c:Nat Nat Nat->State, d:Nat->State,
  s:Int->Nat,
  protect:State Int->nState;

variables B:Bool, N:Int, M:Int, X:Int, Z:Int, m:Nat, n:Nat, x:Nat, y:Nat;

rewrite-system simplifications
  bnot(false)=>true, bnot(true)=>false, bnot(bnot(B))=>B,
  band(false, B)=>false, band(true, B)=>B, band(B, false)=>false,
  band(B, true)=>B, bimplies(true, B)=>B, bimplies(false, B)=>true,
  bor(false, B)=>B, bor(true, B)=>true, bor(B, false)=>B,
  bor(B, true)=>true, mequals(N, N)=>true, bequals(B, B)=>true,
  bequals(true, B)=>B,bequals(false, B)=>bnot(B), bequals(B, true)=>B,
  bequals(B, false)=>bnot(B), band(B, B)=>B, bor(B, B)=>B;

constrained-rewrite-system sum
  a(n) => b(n, s(mzero)),
  b(n, x) => c(n, n, x),
  c(m, s(N), s(X)) /\ band(mle(mone,N),mle(mzero,X)) => c(m, s(mminus(N,mone)), s(mplus(X,mone))),
  c(s(M), s(mzero), x) /\ mle(mone,M) => c(s(mminus(M,mone)), s(mminus(M,mone)), x),
  c(s(mzero), s(mzero), x) => d(x);
  

// constrained-rewrite-system circ1

//   a(n) => d(x),
//   c(n, m, x) => d(y);

/*
  The proof obligations
*/
constrained-rewrite-system circ2

  a(s(N)) /\ mle(mzero,N) => d(s(mdiv(mtimes(N,mplus(N,mone)),mtwo))),
  c(s(N), s(M), s(X)) /\ band(mle(mzero,N),band(mle(mzero,M),mle(mzero,X))) => d(s(mplus(mplus(M,X),mdiv(mtimes(N,mminus(N,mone)),mtwo))));

instrument sum sum_protected State nState protect;

/*

// If we try to prove total correctness using a variant = O(N), this
// will not work.

cinstrument circ2 circ2_p State nState protect mplus(mplus(N,N),mplus(N,mplus(mhundred, mhundred))) mplus(mplus(N,M),mplus(N,mhundred));

prove in sum_protected : circ2_p;

*/

// However, if we choose the variant = O(N^2)
cinstrument circ2 circ2_p State nState protect
   mplus(mhundred,mplus(mhundred,mplus(N,mtimes(mtimes(N,N),mthree)))) // variant for the first circularity
   mplus(mhundred,mplus(M,mtimes(mtimes(N,N),mthree)));                // vairant for the second circularity

prove in sum_protected : circ2_p;
// the proof suceeeds:
/*
rmt -v 0 < 4.1-square-variant.rmt | grep "#"
Proving circularity #1:
Circularity #1 proved.
Proving circularity #2:
Circularity #2 proved.
*/

// Note that by the desing of reachability logic, both circularities in circ2
// need to succeed in order to trust either of them.
