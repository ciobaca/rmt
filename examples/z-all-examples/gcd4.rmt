smt-prelude "(define-fun samedivs ((x Int) (y Int) (u Int) (v Int)) Bool
   (forall ((d Int))
     (iff (and (= 0 (mod x d)) (= 0 (mod y d)))
          (and (= 0 (mod u d)) (= 0 (mod v d)))))
)
(define-fun isdivisor ((d Int) (x Int) (y Int))
  (and
     (= 0 (mod x d))
     (= 0 (mod y d)))
)
(define-fun isgcd ((d Int) (x Int) (y Int))
  (and (isdivisor d x y)
       (forall ((e Int)) (=> (isdivisor e x y) (<= e d))))
)
(assert (forall ((X Int)) (= 0 (mod 0 X))))
(assert (forall ((X Int) (Y Int)) (=> (not (= Y 0)) (samedivs X Y Y (mod X Y)))))"

sorts Int / "Int", Bool / "Bool", State;
// subsort Int < State;

signature mzero : -> Int / "0", mone : -> Int / "1", mtwo : -> Int / "2", mthree : -> Int / "3",
  mplus : Int Int->Int / "+", mminus : Int Int->Int / "-",
  mtimes : Int Int->Int / "*", mdiv : Int Int->Int / "div",
  mle : Int Int->Bool / "<=", mequals : Int Int->Bool / "=",
  mgcd : Int Int -> Int / "gcd", mg : Int Int -> Bool / ">",
  mmod : Int Int -> Int / "mod",

  bequals : Bool Bool->Bool / "=", band : Bool Bool->Bool / "and",
  bimplies : Bool Bool->Bool / "=>", bor : Bool Bool->Bool / "or",
  bnot : Bool->Bool / "not", true : ->Bool / "true", false : ->Bool / "false",
  samedivs : Int Int Int Int -> Bool / "samedivs",
  isgcd : Int Int Int -> Bool / "isgcd",

  init : Int Int -> State, loop : Int Int Int Int -> State, done : Int Int Int -> State,
  ok : Int Int -> State;

variables S : Int, N : Int, I : Int, J : Int, X : Int, Y : Int, Z : Int, A : Int, B : Int,
 C : Int, D : Int, BB : Bool;

rewrite-system simplifications
  bnot(false) => true, bnot(true) => false, bnot(bnot(BB)) => BB,
  band(false, BB) => false, band(true, BB) => BB, band(BB, false) => false,
  band(BB, true) => BB, bimplies(true, BB) => BB, bimplies(false, BB) => true,
  bor(false, BB) => BB, bor(true, BB) => true, bor(BB, false) => BB,
  bor(BB, true) => true, mequals(N, N) => true, bequals(BB, BB) => true,
  bequals(true, BB) => BB,bequals(false, BB) => bnot(BB), bequals(BB, true) => BB,
  bequals(BB, false) => bnot(BB), band(BB, BB) => BB, bor(BB, BB) => BB;

constrained-rewrite-system gcd
  init(X, Y) => loop(X, Y, X, Y),

  loop(I, J, X, Y) /\ bnot(mequals(Y, mzero)) =>
  loop(I, J, Y, mmod(X, Y)),

  loop(I, J, X, Y) /\ mequals(Y, mzero) =>
  done(I, J, X),

  done(I, J, X) /\ isgcd(X, I, J) => ok(I, J);

constrained-rewrite-system circ
  init(X, Y) => ok(X, Y),//done(mgcd(X, Y)),

  loop(X, Y, I, J) /\ samedivs(X, Y, I, J) => ok(X, Y);//done(mgcd(X, Y));

prove [2,2] in gcd : circ;
