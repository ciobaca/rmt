/* any file begins with the declaration of all sorts used */
sorts Int / "Int",
      Bool / "Bool",
      Var,
      AExp,
      BExp,
      NonValAExp,
      NonValBExp,
      Stmt,
      Code,
      CompStack,
      Map,
      MapItem,
      CfgI;

// after declaring all sorts,
// we must declare all subsort relations
subsort Int < AExp;
subsort Var < NonValAExp;
subsort NonValAExp < AExp;
subsort NonValBExp < BExp;
subsort AExp BExp Stmt < Code;
subsort Bool < BExp;

/* next we must declare all function symbols */
signature
	// debug symbols
	debug : AExp -> AExp,
	pairdebug : AExp AExp -> AExp,

	// interpreted integers and booleans
	mzero : -> Int / "0",
	mone : -> Int / "1",
	mplus : Int Int -> Int / "+",
	mminus : Int Int -> Int / "-",
	mle : Int Int -> Bool / "<=",
	true : -> Bool / "true",
	false : -> Bool / "false",

	// some program variables
	x : -> Var,
	y : -> Var,
	z : -> Var,

	// helper functions
	synEq : Var Var -> Stmt / "=",
    	update : Var Int Map -> Stmt,
	updateh : MapItem -> Stmt,
	lookup  : Var Map -> Stmt,
    	lookuph : Var Int Map -> Stmt,

	// arithmetic and boolean expressions
	plus : AExp AExp -> NonValAExp,
	plushl : AExp -> AExp,
    	plushr : AExp -> AExp,

	pred : AExp -> NonValAExp,
	predh : -> AExp,

	succ : AExp -> NonValAExp,
	succh : -> AExp,

	le   : AExp AExp -> NonValBExp,
    	lehl : AExp -> BExp,
    	lehr : AExp -> BExp,

	// computation stack
	done : -> CompStack,
	push : Code CompStack -> CompStack,

	// environment
	mi : Var Int -> MapItem,
	emp : -> Map,
	cons : MapItem Map -> Map,

	// configuration
	I : CompStack Map -> CfgI,

	// statements
	assign : Var AExp -> Stmt,
	updateEnv : -> Stmt,
    	assignh : Var -> Stmt,

	skip : -> Stmt,

	seq : Stmt Stmt -> Stmt,

	ite : BExp Stmt Stmt -> Stmt,
	iteh : Stmt Stmt -> Stmt,

	while : BExp Stmt -> Stmt;

/* next we must declare all variables */
variables
	// temporary variables
// from this term: I(push(ite(_0,seq(seq(assign(z,plus(z,y)),assign(y,plus(y,_1))),while(le(y,x),seq(assign(z,plus(z,y)),assign(y,plus(y,_2))))),skip),done),cons(mi(x,_3),cons(mi(y,_4),cons(mi(z,_5),emp))))
	_0 : Bool,
	_1 : Int,
	_2 : Int,
	_3 : Int,
	_4 : Int,
	_5 : Int,

	// necessary variables
	X : Var,
	Y : Var,
	Z : Var,
	N : Int,
	M : Int,
	SUM : Int,
	B : Bool,
	BE : BExp,
	BE1 : BExp,
	BE2 : BExp,
	AE : AExp,
	AE1 : AExp,
	AE2 : AExp,
	NVAE : NonValAExp,
	NVAE1 : NonValAExp,
	NVAE2 : NonValAExp,
	NVBE : NonValBExp,
	NVBE1 : NonValBExp,
	NVBE2 : NonValBExp,
	S : Stmt,
	S1 : Stmt,
	S2 : Stmt,
	REST : CompStack,
	ENV : Map,
	ENV1 : Map,
	ENV2 : Map;

/* next, declare all rewrite rules */
rewrite
	synEq(x, y) =>
	false,
	synEq(x, z) =>
	false,
	synEq(y, z) =>
	false,
	synEq(y, x) =>
	false,
	synEq(z, y) =>
	false,
	synEq(z, x) =>
	false,
	synEq(x, x) =>
	true,
	synEq(y, y) =>
	true,
	synEq(z, z) =>
	true,

	I(push(update(X, N, emp),   REST), ENV) =>
	I(push(cons(mi(X, N), emp), REST), ENV),

    	I(push(update(X, N, cons(mi(Y, M), ENV1)),   REST), ENV) =>
    	I(push(synEq(X, Y), push(update(X, N, cons(mi(Y, M), ENV1)), REST)), ENV),

    	I(push(true, push(update(X, N, cons(mi(Y, M), ENV1)),   REST)), ENV) =>
    	I(push(cons(mi(X, N), ENV1), REST), ENV),

    	I(push(false, push(update(X, N, cons(mi(Y, M), ENV1)),   REST)), ENV) =>
    	I(push(update(X, N, ENV1), push(updateh(mi(Y, M)), REST)), ENV),

    	I(push(ENV1, push(updateh(mi(Y, M)),   REST)), ENV) =>
    	I(push(cons(mi(Y, M), ENV1), REST), ENV),

	I(push(lookup(X, cons(mi(Y, M), ENV1)),   REST), ENV) =>
	I(push(synEq(X, Y), push(lookuph(X, M, ENV1), REST)), ENV),

	I(push(true, push(lookuph(X, M, ENV1),   REST)), ENV) =>
	I(push(M,                                REST),  ENV),

	I(push(false, push(lookuph(X, M, ENV1),  REST)), ENV) =>
	I(push(lookup(X, ENV1),                  REST),  ENV),

 	I(push(X,              REST), ENV) =>
 	I(push(lookup(X, ENV), REST), ENV),

	I(push(pred(N),            REST), ENV) =>
	I(push(mminus(N, mone),    REST), ENV),

	I(push(pred(NVAE),       REST) , ENV) =>
	I(push(NVAE, push(predh, REST)), ENV),

	I(push(N, push(predh, REST)), ENV) =>
	I(push(pred(N),       REST) , ENV),

	I(push(succ(N),           REST), ENV) =>
	I(push(mplus(N, mone),    REST), ENV),

	I(push(succ(NVAE),       REST) , ENV) =>
	I(push(NVAE, push(succh, REST)), ENV),

	I(push(N, push(succh, REST)), ENV) =>
	I(push(succ(N),       REST) , ENV),

	I(push(assign(X, N),                      REST), ENV) =>
        I(push(update(X, N, ENV), push(updateEnv, REST)), emp),

        I(push(ENV,  push(updateEnv, REST)), emp) =>
	I(push(skip,                 REST), ENV),
    
 	I(push(assign(X, NVAE),       REST) , ENV) =>
 	I(push(NVAE, push(assignh(X), REST)), ENV),

     	I(push(N, push(assignh(X), REST)), ENV) =>
     	I(push(assign(X, N),        REST) , ENV),

// sequential composition
	I(push(seq(S1, S2), REST) , ENV) =>
	I(push(S1, push(S2, REST)), ENV),

	I(push(skip, REST), ENV) =>
	I(           REST , ENV),

// conditional statement

	I(push(ite(NVBE, S1, S2),       REST) , ENV) =>
	I(push(NVBE, push(iteh(S1, S2), REST)), ENV),

	I(push(B, push(iteh(S1, S2), REST)), ENV) =>
	I(push(ite(B, S1, S2),       REST) , ENV),

	I(push(ite(true, S1, S2), REST), ENV) =>
	I(push(S1,                REST), ENV),

 	I(push(ite(false, S1, S2), REST), ENV) =>
 	I(push(S2,                 REST), ENV),

// while statement
 	I(push(while(BE, S),                        REST), ENV) =>
 	I(push(ite(BE, seq(S, while(BE, S)), skip), REST), ENV),

// addition operator
 	I(push(plus(N, M),     REST), ENV) =>
 	I(push(mplus(N, M),    REST), ENV),

	I(push(plus(NVAE1, AE2),        REST) , ENV) =>
	I(push(NVAE1, push(plushl(AE2), REST)), ENV),
  
 	I(push(N, push(plushl(AE2), REST)), ENV) =>
 	I(push(plus(N, AE2)       , REST) , ENV),

 	I(push(plus(N, NVAE2)       , REST) , ENV) =>
 	I(push(NVAE2, push(plushr(N), REST)), ENV),

 	I(push(M, push(plushr(N), REST)), ENV) =>
 	I(push(plus(N, M)       , REST) , ENV),

// less than or equal to operator2

 	I(push(le(N, M),  REST), ENV) =>
 	I(push(mle(N, M), REST), ENV),

 	I(push(le(NVAE1, AE2),        REST) , ENV) =>
 	I(push(NVAE1, push(lehl(AE2), REST)), ENV),

 	I(push(N, push(lehl(AE2), REST)), ENV) =>
 	I(push(le(N, AE2),        REST) , ENV),

 	I(push(le(N, NVAE2),        REST) , ENV) =>
 	I(push(NVAE2, push(lehr(N), REST)), ENV),
  
 	I(push(M, push(lehr(N), REST)), ENV) =>
 	I(push(le(N, M),       REST) , ENV),

	debug(y) =>
	debug(mone),

	debug(y) =>
	debug(mzero);

// run debug(y);

// run I(push(
// 	seq(assign(x, N), 
//   	seq(assign(y, mzero),
// 	seq(assign(z, mzero),
// 	    while(le(y, x),
//                   seq(assign(z, plus(z, y)),
// 		      assign(y, plus(y, mone))))))),
//     done), emp);

//smt-narrow-search I(push(ite(mle(mone, N),seq(seq(assign(z,plus(z,y)),assign(y,plus(y,mone))),while(le(y,x),seq(assign(z,plus(z,y)),assign(y,plus(y,mone))))),skip),done),cons(mi(x,N),cons(mi(y,mzero),cons(mi(z,mzero),emp))));

smt-search I(push(while(le(iY, N), seq(assign(iX, plus(iX, iY)),
    assign(iY, succ(iY)))), done), cons(mi(iX, sum(0, M - 1)), cons(mi(iY, M),
    emp)));

// reduce I(push(
// 	seq(assign(x, N), 
//   	seq(assign(y, mzero),
// 	seq(assign(z, mzero),
// 	    while(le(y, x),
//                   seq(assign(z, plus(z, y)),
// 		      assign(y, plus(y, mone))))))),
//     done), emp);

//rewrite-search pairdebug(debug(y), debug(y));

//narrow-search pairdebug(debug(y), debug(y));

//narrow-search pairdebug(debug(X), debug(X));

//narrow-search I(push(ite(_0,seq(seq(assign(z,plus(z,y)),assign(y,plus(y,_1))),while(le(y,x),seq(assign(z,plus(z,y)),assign(y,plus(y,_2))))),skip),done),cons(mi(x,_3),cons(mi(y,_4),cons(mi(z,_5),emp))));
